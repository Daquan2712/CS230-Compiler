

/*
   NOTES ON USING THIS FILE:
      (1) Store in a convenient directory.
      (2) At the command line, type "javacc Parser.jj"
      (3) At the command line, type "javac Parser.java"
      (4) To run, type "java Parser <inputfilename>".
   It's easy to leave out step 3! The file Parser.java is
   automatically generated by javacc, but is *not* automatically
   compiled by it!
   NB: The *name* of the file Parser.java comes from the name of
   the *class* Parser in this file. Even if you change the name
   of this file, unless you change the name of the Parser class below,
   javacc will still generate a file entitled Parser.java.
 */

PARSER_BEGIN(Parser)

//This part of the code is just plain java.
//The "Parser" class is an executable class with a main method.
//It creates a Parser object named "parser" and invokes its "Input()" method.
//The Input() method is defined in the grammar as a "nonterminal symbol."

import java.io.*;

public class Parser {

  public static void main(String args[]) throws ParseException, FileNotFoundException {
    Parser parser = new Parser(new FileInputStream (args[0]));
    AST parsedTree = parser.Input();
    System.out.println(parsedTree.toString());
  }
}

abstract class AST {}
//This class is to represent a node which contains an integer
class Num extends AST {
  int value;
  Num(Token t) {
    value = Integer.parseInt(t.image);
  }
  public String toString() {return value + "";}
}

//This class is to represent a node which contains symbols/variables
class NonNum extends AST {
  String value;
  NonNum(Token t) {
    value = t.image;
  }
  public String toString() {return value;}
}

//This is the class that represents the expression which has a String operation and a left and a right child
//
class BinaryExpression extends AST {
  String op;
  AST left, right;
  BinaryExpression(String o, AST l, AST r) {
    op = o;
    left = l;
    right = r;
  }
  public String toString() {
    if (left == null && right != null) {
      return "(" + op + " " + right + ")";
    } else if (right == null && left != null) {
      return "(" + op + " " + left + ")";
    } else if (right == null && left == null) {
      return "";
    } else {
      return "(" + op + " " + left + " " + right + ")";
    }
  }
}


PARSER_END(Parser)

/*  Specification of tokens */

//Here we specify the whitespace that is skipped.
SKIP :
{
  " "
  | "\t"
  | "\n"
  | "\r"
}

//Here the token classes are defined along
//with the explicit lexemes.
TOKEN :
{
   <addop: "+" | "-" | "||" >
 | <keyw: "void"|"main">
 | <keywIf: "if">
 | <keywElse: "else">
 | <keywLoop: "while">
 | <type: "int"|"bool">
 | <identifier: ["a"-"z"](["a"-"z"])*(["0"-"9"])* | ["a"-"z"]((["a"-"z"])*(["A"-"Z"])*(["0"-"9"])*)* | ["A"-"Z"](["A"-"Z"])*(["0"-"9"])* | ["A"-"Z"]((["A"-"Z"])*(["a"-"z"])*(["0"-"9"])*)*> //ask again so many cases of an identifier can be
 | <num: ["0"-"9"](["0"-"9"])*>
 | <negop: "!">
 | <relop: "=="|"!="|"<"|"<="|">"|">=">
 | <assignop: "=">
 | <mulop: "*"|"/"|"%"|"&&">
 | <begin: "{">
 | <end: "}">
 | <openparen: "(">
 | <closeparen: ")">
 | <semicolon: ";">
 | <comma: ",">
}

/* Specification of Language */

//The Input() symbol is just a wrapper for the Program() symbol.
AST Input() :
{AST result; }
{
  result = Program() <EOF>
  {return result;}
}

//Program() is the legit start symbol for this grammar. At this point,
//we just regard it as a string of tokens, as specified above. The
//statements in brackets are executed when the tokens are
//recognized.
//Rule: program -> void main() <block>
AST Program() :
{Token t; AST res;}
{   
    t = <keyw> //return type; only void for now
    t = <keyw> //main
    t = <openparen> 
    t = <closeparen> 
    t = <begin> res = Block()
    {return res;}
    
}

//Rule: <block> -> { <declarations> <optional_statements>?}
AST Block():
{Token t; AST left = null; AST right = null;}
{
  //t = <begin> //symbol "{"
  left = Declarations()
  [right = Optional_Statement()]
  t = <end> //symbol "}"
  {return new BinaryExpression("program", left, right);}
}

//Rule: <declarations> -> (<declaration>)*
AST Declarations():
{AST left = null; AST temp = null;}
{
  (temp = Declaration() { 
    if (left == null) {
      left = temp;
    } else {
      left = new BinaryExpression(";", left, temp);
    }
    })*
  
  {return left;}
}

//Rule: <declaration> -> <type> <identifier_list>;
AST Declaration():
{Token t; AST left = null; AST right = null;}
{
	t = <type> {left = new NonNum(t);}
	right = Identifier_List()
	t = <semicolon> 
  {return new BinaryExpression(":", left, right);}
}

//Rule: <identifier_list> -> <id> (, <id>)*
AST Identifier_List():
{Token t; AST left = null; AST right = null;}
{
	t = <identifier> //a variable
  {left = new NonNum(t);}
	(t = <comma> 
    t = <identifier>
   {right = new NonNum(t); left = new BinaryExpression(",", left, right);})*
  {return left;}
}

//Rule: <optional_statements> -> <statement_list>
AST Optional_Statement():
{AST res = null;}
{
  res = Statement_List()
  {return res;}
}

//Rule: <statement_list> -> <statement> (<statement>)*
AST Statement_List():
{Token t; AST left = null; AST right = null; AST temp = null;}
{
  left = Statement()
  //Haven't solved yet!!!
  (right = Statement() {left = new BinaryExpression(";", left, right);})* 
  {return left;}
}

//Rule: <statement> -> <variable><assignop><expression>; 
//						| <block>
//						| if (<expression>) <statement> <else_clause>
//						| while (<expression>) <statement>
AST Statement():
{Token t;}
{
  t = <identifier> {return Statement_Expression(t);}
  | t = <keywIf> {return Statement_If();}
  | t = <keywLoop> {return Statement_While();}
  | t = <begin> {return Block();} //if the next token is "{" => a new block
}

//if it reads a variable for the rule <statement>, goes to this function
//Rule: <statement> -> <variable><assignop><expression>;
AST Statement_Expression(Token var):
{Token t; AST left = null; AST right = null; String op;}
{
  t = <assignop> {left = new NonNum(var); op = t.image;}
  right = Expression()
  t = <semicolon>
  {return new BinaryExpression(op, left, right);}
}

//if it reads an "if" keyword, goes to this function
//Rule: <statement> -> if (<expression>) <statement> <else_clause>
AST Statement_If():
{Token t; AST left = null; AST right = null; AST ifTrue = null;}
{
	t = <openparen> 
	left = Expression() //this is the condition
	t = <closeparen> 

	ifTrue = Statement() //If the condition is true
	right = Statement_Else(ifTrue) //Otherwise
  {return new BinaryExpression("If", left, right);}
}

//An If statement has to be followed with an Else
//Rule: <else_clause> -> (else <statement>)?
AST Statement_Else(AST ifTrue):
{Token t; AST left = null; AST right = null;}
{
	[t = <keywElse> 
  right = Statement()
  {left = ifTrue; return new BinaryExpression("Else", left, right);}]

  //if no else then if the "else" node only contains the statement if "if" is true
  {left = ifTrue; return new BinaryExpression("Else", left, null);} 
}

//if it reads a While keyword, goes to this function
//Rule: <statement> -> while (<expression>) <statement>
AST Statement_While():
{Token t; AST left = null; AST right = null;}
{
	t = <openparen> 
	left = Expression() //condition
	t = <closeparen> 
	right = Statement() //statement if condition is true
  {return new BinaryExpression("while", left, right);}
}

//Rule: <expression> -> <simple_expression> <relopclause>
AST Expression():
{Token t; AST left = null; SingleExpression right = null;}
{
  left = Simple_Expression()
  right = Relop_Clause()
  {if (right == null) 
      return left;
    else
      return new BinaryExpression(right.getOp(), left, right.getExpr());
  }
}

//Rule: <relopclause> -> <relop> <simple_expression> | empty
SingleExpression Relop_Clause():
{Token t; AST expr = null;}
{
	[t = <relop> 
	 expr = Simple_Expression() {return new SingleExpression(t.image, expr);}] 
  {return null;}
}

//Rule: <simple_expression> -> <term> (<addop><term>)*
AST Simple_Expression():
{Token t; AST left = null; AST right = null;}
{ 
  left = Term() 
  (t = <addop> {right = Term(); left = new BinaryExpression(t.image, left, right);})*
  {return left;}
}

//Rule: <term> -> <factor> (<mulop><factor>)*
//It seems like we don't need the option | <addop> <term> as it is considered in 
//simple_expression already
AST Term():
{Token t; AST left = null; AST right = null;}
{
  left = Factor()
  (t = <mulop> {right = Factor(); left = new BinaryExpression(t.image, left, right);})* 
  {return left;}
}

//Rule: <factor> -> <id> | (<expression>) | <num> | !<factor>
AST Factor():
{Token t; AST temporaryAST = null;}
{
  t = <identifier> {return new NonNum(t);}
  | t = <openparen> {temporaryAST = Expression(); Close_Paren(); return temporaryAST;}
  | t = <num> {return new Num(t);}
  | t = <negop> {temporaryAST = Factor(); return new BinaryExpression(t.image, temporaryAST, null);}
}
//This function is to check if a close parenthesis exists after an open parenthesis
//and it is invoked in Factor() in case a token read <openparen>
void Close_Paren():
{Token t;}
{
  t = <closeparen>
}